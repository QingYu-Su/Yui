package server

import (
	"encoding/hex"
	"fmt"
	"log"
	"net"
	"os"
	"path/filepath"

	"github.com/QingYu-Su/Yui/internal"
	"github.com/QingYu-Su/Yui/internal/server/data"
	"github.com/QingYu-Su/Yui/internal/server/multiplexer"
	"github.com/QingYu-Su/Yui/internal/server/tcp"
	"github.com/QingYu-Su/Yui/internal/server/webhooks"
	"github.com/QingYu-Su/Yui/internal/server/webserver"
	"github.com/QingYu-Su/Yui/pkg/mux"
	"golang.org/x/crypto/ssh"
)

// CreateOrLoadServerKeys 创建或加载服务器SSH密钥
// privateKeyPath: 私钥文件路径
// 返回: SSH签名器和错误信息
func CreateOrLoadServerKeys(privateKeyPath string) (ssh.Signer, error) {
	// 检查私钥文件是否存在，如果不存在则生成新密钥
	if _, err := os.Stat(privateKeyPath); os.IsNotExist(err) {
		// 生成新的私钥
		privateKeyPem, err := internal.GeneratePrivateKey()
		if err != nil {
			return nil, fmt.Errorf("unable to generate private key, and no private key specified: %s", err)
		}

		// 将私钥写入文件
		err = os.WriteFile(privateKeyPath, privateKeyPem, 0600)
		if err != nil {
			return nil, fmt.Errorf("unable to write private key to disk: %s", err)
		}
	}

	// 读取私钥文件内容
	privateBytes, err := os.ReadFile(privateKeyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load private key (%s): %s", privateKeyPath, err)
	}

	// 解析私钥
	private, err := ssh.ParsePrivateKey(privateBytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse private key: %s", err)
	}

	return private, nil
}

// Run 启动服务器主函数
// addr: 服务器监听地址
// dataDir: 数据目录路径
// connectBackAddress: 连接回传地址
// autogeneratedConnectBack: 是否自动生成连接回传地址
// TLSCertPath: TLS证书路径
// TLSKeyPath: TLS密钥路径
// insecure: 是否启用不安全模式
// enabledDownloads: 是否启用下载功能
// enabletTLS: 是否启用TLS
// openproxy: 是否启用开放代理
// timeout: TCP保持连接超时时间
func Run(addr, dataDir, connectBackAddress string, autogeneratedConnectBack bool, TLSCertPath, TLSKeyPath string, insecure, enabledDownloads, enabletTLS, openproxy bool, timeout int) {
	// 配置多路复用器
	c := mux.MultiplexerConfig{
		Control:           true,               // 启用控制通道
		Downloads:         enabledDownloads,   // 是否启用下载
		TLS:               enabletTLS,         // 是否启用TLS
		TLSCertPath:       TLSCertPath,        // TLS证书路径
		TLSKeyPath:        TLSKeyPath,         // TLS密钥路径
		AutoTLSCommonName: connectBackAddress, // 自动TLS通用名称
		TcpKeepAlive:      timeout,            // TCP保持连接时间
		// 轮询认证检查函数
		PollingAuthChecker: func(key string, addr net.Addr) bool {
			// 解码十六进制格式的授权密钥
			authorizedKey, err := hex.DecodeString(key)
			if err != nil {
				return false
			}

			// 解析公钥
			pubKey, err := ssh.ParsePublicKey(authorizedKey)
			if err != nil {
				return false
			}

			// 检查授权密钥是否有效
			_, err = CheckAuth(filepath.Join(dataDir, "authorized_controllee_keys"), pubKey, getIP(addr.String()), insecure)
			return err == nil
		},
	}

	// 设置私钥路径
	privateKeyPath := filepath.Join(dataDir, "id_ed25519")

	// 打印版本信息
	log.Println("Version: ", internal.Version)

	// 启动多路复用器监听
	var err error
	multiplexer.ServerMultiplexer, err = mux.ListenWithConfig("tcp", addr, c)
	if err != nil {
		log.Fatalf("Failed to listen on %s (%s)", addr, err)
	}
	defer multiplexer.ServerMultiplexer.Close() // 确保在函数退出时关闭监听

	log.Printf("Listening on %s\n", addr)

	// 创建或加载服务器密钥
	private, err := CreateOrLoadServerKeys(privateKeyPath)
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("Loading private key from: %s\n", privateKeyPath)

	// 打印服务器密钥指纹
	log.Println("Server key fingerprint: ", internal.FingerprintSHA256Hex(private.PublicKey()))

	// 如果启用了下载功能
	if enabledDownloads {
		// 如果没有指定连接回传地址，使用监听地址
		if len(connectBackAddress) == 0 {
			connectBackAddress = addr
		}
		// 启动Web服务器处理HTTP下载请求
		go webserver.Start(multiplexer.ServerMultiplexer.HTTPDownloadRequests(), connectBackAddress, autogeneratedConnectBack, "../", dataDir, private.PublicKey())
		// 启动TCP服务器处理TCP下载请求
		go tcp.Start(multiplexer.ServerMultiplexer.TCPDownloadRequests())
	}

	// 加载数据库
	err = data.LoadDatabase(filepath.Join(dataDir, "data.db"))
	if err != nil {
		log.Fatal(err)
	}

	// 启动Webhooks
	go webhooks.StartWebhooks()

	// 启动SSH服务器处理控制请求
	StartSSHServer(multiplexer.ServerMultiplexer.ControlRequests(), private, insecure, openproxy, dataDir, timeout)
}
